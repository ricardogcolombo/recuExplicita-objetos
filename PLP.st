Object subclass: #Regex	instanceVariableNames: 'expresion'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!Regex commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	expresion:		<Object>    Implementation Points!!Regex methodsFor: 'copying' stamp: 'alanLebe 7/1/2018 22:50'!, aRegex	|subExp|	subExp := (Concatenate new) initializeWithSubExpresionLeft: self andSubExpresionRight: aRegex.	^ (Regex new) initializeWith: subExp.! !!Regex methodsFor: 'initialization' stamp: 'alanLebe 7/1/2018 22:24'!initializeWith: anExpresion	expresion := anExpresion.! !!Regex methodsFor: 'initialization' stamp: 'alanLebe 7/1/2018 22:21'!initializeWithSymbol: aSymbol 	expresion := (Symbolo new) initializeWith: aSymbol.! !!Regex methodsFor: 'initialization' stamp: 'alanLebe 6/30/2018 20:12'!initializeWithEmpty 	expresion := Empty new.! !!Regex methodsFor: 'logical operations' stamp: 'alanLebe 7/1/2018 22:50'!| aRegex	|subExp|	subExp := (Union new) initializeWithSubExpresionLeft: self andSubExpresionRight: aRegex.	^ (Regex new) initializeWith: subExp.! !!Regex methodsFor: 'as yet unclassified' stamp: 'alanLebe 7/1/2018 22:45'!star	|subExp|	subExp := (Star new) initializeWith: self.	^ (Regex new) initializeWith: subExp.! !!Regex methodsFor: 'evaluating' stamp: 'alanLebe 7/1/2018 22:51'!prefix	^ expresion prefix.! !!Regex methodsFor: 'evaluating' stamp: 'alanLebe 7/4/2018 18:25'!match: aString	|chains|	chains := self allChainsWithSize: aString size.	^ chains includes: aString.! !!Regex methodsFor: 'evaluating' stamp: 'alanLebe 7/2/2018 01:12'!printString	^ expresion printString.! !!Regex methodsFor: 'evaluating' stamp: 'alanLebe 7/1/2018 22:50'!option2	^ expresion option2.! !!Regex methodsFor: 'evaluating' stamp: 'alanLebe 7/1/2018 22:51'!suffix	^ expresion suffix.! !!Regex methodsFor: 'evaluating' stamp: 'alanLebe 7/1/2018 22:48'!option1	^ expresion option1.! !!Regex methodsFor: 'evaluating' stamp: 'alanLebe 7/1/2018 22:30'!value	^ expresion value.! !!Regex methodsFor: 'evaluating' stamp: 'alanLebe 7/2/2018 01:11'!hasStar	^ expresion hasStar.! !!Regex methodsFor: 'evaluating' stamp: 'alanLebe 6/30/2018 21:47'!isNotNil	^ (expresion = nil) not.! !!Regex methodsFor: 'evaluating' stamp: 'alanLebe 7/4/2018 18:24'!allChainsWithSize: aSize	^ expresion allChainsWithSize: aSize.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Regex class	instanceVariableNames: ''!!Regex class methodsFor: 'requirements' stamp: 'alanLebe 7/2/2018 00:33'!c	^self new initializeWithSymbol: $c.! !!Regex class methodsFor: 'requirements' stamp: 'alanLebe 7/1/2018 22:37'!b	^self new initializeWithSymbol: $b.! !!Regex class methodsFor: 'requirements' stamp: 'alanLebe 6/30/2018 20:11'!empty	^self new initializeWithEmpty.! !!Regex class methodsFor: 'requirements' stamp: 'alanLebe 7/1/2018 22:37'!a	^self new initializeWithSymbol: $a.! !Regex subclass: #Concatenate	instanceVariableNames: 'leftSubExpresion rightSubExpresion'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!Concatenate commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	subExpresion:		<Object>    Implementation Points!!Concatenate methodsFor: 'initialization' stamp: 'alanLebe 7/1/2018 22:52'!prefix	^ leftSubExpresion.! !!Concatenate methodsFor: 'initialization' stamp: 'alanLebe 7/1/2018 22:52'!suffix	^ rightSubExpresion.! !!Concatenate methodsFor: 'initialization' stamp: 'alanLebe 6/30/2018 21:27'!initializeWithSubExpresionLeft: aRegex andSubExpresionRight: anotherRegex.	leftSubExpresion := aRegex.	rightSubExpresion := anotherRegex.! !!Concatenate methodsFor: 'initialization' stamp: 'alanLebe 7/2/2018 01:24'!printString	^ (leftSubExpresion printString) , (rightSubExpresion printString).! !!Concatenate methodsFor: 'initialization' stamp: 'alanLebe 7/4/2018 18:18'!allChainsWithSize: aSize	|leftChains rightChains allChains|	leftChains := leftSubExpresion allChainsWithSize: aSize.	rightChains := rightSubExpresion allChainsWithSize: aSize.	allChains := Set new.		leftChains do: [:leftChain| rightChains do: 							[:rightChain| (leftChain , rightChain) size <= aSize ifTrue: [ allChains add: (leftChain , rightChain) ]  							]].						^ allChains.			! !!Concatenate methodsFor: 'initialization' stamp: 'alanLebe 7/2/2018 01:03'!hasStar	^ (leftSubExpresion hasStar) or: (rightSubExpresion hasStar).! !Regex subclass: #Empty	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!Empty commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!Empty methodsFor: 'testing' stamp: 'alanLebe 7/4/2018 17:58'!allChainsWithSize: aSize	|chains|	chains := Set new.	chains add: '' asString.	^ chains.! !!Empty methodsFor: 'testing' stamp: 'alanLebe 7/2/2018 01:10'!hasStar	^ false.! !!Empty methodsFor: 'testing' stamp: 'alanLebe 7/2/2018 01:13'!printString	^ 'empty'.! !!Empty methodsFor: 'testing' stamp: 'alanLebe 7/2/2018 01:10'!value	^ self.! !Regex subclass: #Star	instanceVariableNames: 'subExpresion'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!Star commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!Star methodsFor: 'initialization' stamp: 'alanLebe 6/30/2018 20:00'!initializeWith: anExpresion	subExpresion := anExpresion.! !!Star methodsFor: 'initialization' stamp: 'alanLebe 6/30/2018 21:49'!value	^ subExpresion.! !!Star methodsFor: 'initialization' stamp: 'alanLebe 7/4/2018 18:59'!allChainsWithSize: aSize	|chains chainAcum|	chains := subExpresion allChainsWithSize: aSize.	chainAcum := ''.		chains do: [:chain| [(chainAcum , chain) size <= aSize] whileTrue: 					[ chainAcum := (chainAcum , chain).		  			  chains add: chainAcum. 		  					]].  					   chains add: ''.						^ chains.	! !!Star methodsFor: 'initialization' stamp: 'alanLebe 7/2/2018 01:08'!hasStar	^ true.! !!Star methodsFor: 'initialization' stamp: 'alanLebe 7/2/2018 01:22'!printString	^ '(' , (subExpresion printString) , ')*'.! !Regex subclass: #Symbolo	instanceVariableNames: 'symbol'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!Symbolo commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!Symbolo methodsFor: 'instance creation' stamp: 'alanLebe 7/1/2018 22:22'!initializeWith: aSymbol	symbol := aSymbol.! !!Symbolo methodsFor: 'instance creation' stamp: 'alanLebe 6/30/2018 21:48'!value	^ symbol.! !!Symbolo methodsFor: 'instance creation' stamp: 'alanLebe 7/4/2018 17:59'!allChainsWithSize: aSize	|chains|	chains := Set new.	chains add: symbol asString.	^ chains.! !!Symbolo methodsFor: 'instance creation' stamp: 'alanLebe 7/2/2018 01:08'!hasStar	^ false.! !!Symbolo methodsFor: 'instance creation' stamp: 'alanLebe 7/2/2018 01:19'!printString	^ symbol asString.! !TestCase subclass: #TestEj1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!TestEj1 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/6/2018 23:24'!test1_1_regex	|e a b aaa a_b ab|		e := Regex empty.	a := Regex a.	b := Regex b.	aaa := a star.	a_b := a | b.	ab := a , b.		self assert: e isNotNil.	self assert: a isNotNil.	self assert: b isNotNil.	self assert: a_b isNotNil.	self assert: aaa isNotNil.	self assert: ab isNotNil.		self assert: a value equals: $a.	self assert: b value equals: $b.	self assert: aaa value equals: a.	self assert: a_b option1 equals: a.	self assert: a_b option2 equals: b.	self assert: ab prefix equals: a.	self assert: ab suffix equals: b.! !TestCase subclass: #TestEj2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!TestEj2 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 21:53'!test2_2_printString	|e a b c aaa abc b_c aaab_c|		e := Regex empty.	a := Regex a.	b := Regex b.	c := Regex c.	aaa := a star.	abc := a , b , c.	b_c := b | c.	aaab_c := aaa , b_c.		self assert: e printString equals: 'empty'.	self assert: a printString equals: 'a'.	self assert: abc printString equals: 'abc'.	self assert: b_c printString equals: '(b|c)'.	self assert: aaa printString equals: '(a)*'.	self assert: aaab_c printString equals: '(a)*(b|c)'.! !!TestEj2 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/6/2018 03:48'!test2_1_hasStar	|e a b c aaa b_c aaab_c|		e := Regex empty.	a := Regex a.	b := Regex b.	c := Regex c.	aaa := a star.	b_c := b | c.	aaab_c := aaa , b_c.		self assert: aaa hasStar.	self assert: aaab_c hasStar.	self assert: e hasStar not.	self assert: a hasStar not.	self assert: b_c hasStar not.! !TestCase subclass: #TestEj3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!TestEj3 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 00:10'!test3_1_minLength	|e a b c aaa b_c aaab_c min|		e := Regex empty.	a := Regex a.	b := Regex b.	c := Regex c.	aaa := a star.	b_c := b | c.	aaab_c := aaa , b_c.	min := [:x :y | x min: y].		self assert: (aaa length: min) equals: 0.	self assert: (aaab_c length: min) equals: 1.	self assert: (e length: min) equals: 0.	self assert: (a length: min) equals: 1.	self assert: (b_c length: min) equals: 1.! !!TestEj3 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 00:09'!test3_2_maxLength	|e a b c aaa b_c aaab_c max|		e := Regex empty.	a := Regex a.	b := Regex b.	c := Regex c.	aaa := a star.	b_c := b | c.	aaab_c := aaa , b_c.	max := [:x :y | x max: y].		self assert: (aaa length: max) isInfinite.	self assert: (aaab_c length: max) isInfinite.	self assert: (e length: max) equals: 0.	self assert: (a length: max) equals: 1.	self assert: (b_c length: max) equals: 1.! !TestCase subclass: #TestEj4	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!TestEj4 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 00:07'!test4_4_or	|a b a_b|		a := Regex a.	b := Regex b.	a_b := a | b.		self assert: (a_b match: 'a').	self assert: (a_b match: 'b').	self assert: (a_b match: '') not.	self assert: (a_b match: 'ab') not.	self assert: (a_b match: 'ba') not.! !!TestEj4 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 00:06'!test4_3_concat	|a b ab|		a := Regex a.	b := Regex b.	ab := a , b.		self assert: (ab match: 'ab').	self assert: (ab match: '') not.	self assert: (ab match: 'a') not.	self assert: (ab match: 'aba') not.! !!TestEj4 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 00:06'!test4_2_char	|a b|		a := Regex a.	b := Regex b.		self assert: (a match: 'a').	self assert: (a match: '') not.	self assert: (a match: 'b') not.	self assert: (a match: 'ab') not.		self assert: (b match: 'b').	self assert: (b match: '') not.	self assert: (b match: 'a') not.	self assert: (b match: 'ba') not.! !!TestEj4 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 00:08'!test4_5_star	|a aaa|		a := Regex a.	aaa := a star.		self assert: (aaa match: '').	self assert: (aaa match: 'a').	self assert: (aaa match: 'aa').	self assert: (aaa match: ('a' repeat: (Random new nextInt: 10))).	self assert: (aaa match: 'b') not.	self assert: (aaa match: 'ab') not.	self assert: (aaa match: 'aab') not.! !!TestEj4 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 00:06'!test4_1_empty	|e|		e := Regex empty.		self assert: (e match: '').	self assert: (e match: 'a') not.! !!TestEj4 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/11/2018 22:32'!test4_6_match	|a b c b_c aaa aaab_c bbbb|		a := Regex a.	b := Regex b.	c := Regex c.	aaa := a star.	b_c := b | c.	aaab_c := aaa , b_c.	bbbb := b star , b.		self assert: (aaab_c match: 'b').	self assert: (aaab_c match: 'c').	self assert: (aaab_c match: 'ab').	self assert: (aaab_c match: 'ac').	self assert: (aaab_c match: 'aab').	self assert: (aaab_c match: 'aaac').	self assert: (bbbb match: 'b').	self assert: (bbbb match: 'bb').	self assert: (bbbb match: 'bbb').	self assert: (bbbb match: '') not.	self assert: (aaab_c match: '') not.	self assert: (aaab_c match: 'a') not.	self assert: (aaab_c match: 'aa') not.	self assert: (aaab_c match: 'aaa') not.	self assert: (aaab_c match: 'ba') not.	self assert: (aaab_c match: 'ca') not.! !Regex subclass: #Union	instanceVariableNames: 'leftSubExpresion rightSubExpresion'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!Union commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	subExpresion:		<Object>    Implementation Points!!Union methodsFor: 'initialization' stamp: 'alanLebe 6/30/2018 21:51'!option2	^ rightSubExpresion.	! !!Union methodsFor: 'initialization' stamp: 'alanLebe 6/30/2018 21:51'!option1	^ leftSubExpresion.	! !!Union methodsFor: 'initialization' stamp: 'alanLebe 6/30/2018 21:51'!initializeWithSubExpresionLeft: aRegex andSubExpresionRight: anotherRegex	leftSubExpresion := aRegex.	rightSubExpresion := anotherRegex.! !!Union methodsFor: 'initialization' stamp: 'alanLebe 7/4/2018 18:34'!allChainsWithSize: aSize	|leftChains rightChains allChains|	leftChains := leftSubExpresion allChainsWithSize: aSize.	rightChains := rightSubExpresion allChainsWithSize: aSize.	leftChains addAll: rightChains.						^ leftChains.! !!Union methodsFor: 'initialization' stamp: 'alanLebe 7/2/2018 01:03'!hasStar	^ (leftSubExpresion hasStar) or: (rightSubExpresion hasStar).! !!Union methodsFor: 'initialization' stamp: 'alanLebe 7/2/2018 01:24'!printString	^ '(' , (leftSubExpresion printString) , '|' , (rightSubExpresion printString) , ')'.	! !